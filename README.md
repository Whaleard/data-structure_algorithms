# data-structure_algorithms
二维数组转稀疏数组案例
                                      row  col  val
0 0 0 0 0 0 0 0 0 0 0             0   11   11   2
0 0 1 0 0 0 0 0 0 0 0             1   1    2    1
0 0 0 2 0 0 0 0 0 0 0             2   2    3    2
0 0 0 0 0 0 0 0 0 0 0             
0 0 0 0 0 0 0 0 0 0 0   ——————>         
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0

约瑟夫问题案例
    设编号为1到5的5个人围坐一圈，约定编号为3的人从1开始报数，数到2的那个人出列，
    它的下一位又从1开始报数，数到2的那个人又出列，以此类推，直到所有人出列为止，由此产生一个出队编号的序列。

    3 -> 4 -> 5 -> 1 -> 2   4出列
    5 -> 1 -> 2 -> 3        1出列
    2 -> 3 -> 5             3出列         出队列的顺序：4->1->3->2->5
    5 -> 2                  2出列
    5                       5出列

栈实现表达式计算案例
    3 + 2 * 6 - 2

    3入栈 -> +入栈 -> 2入栈 -> *优先级大于+，故直接入栈 -> 6入栈 -> -优先级小于*，故6、2出栈，*出栈，进行2*6运算，得到结果12入栈，-入栈 -> 2入栈
    表达式扫描完毕后，将2、12出栈，-出栈，进行12-2运算，将结果10入栈；再将3、10出栈，+出栈，进行3+10运算，将结果13入栈，此时符号栈无数据，数栈中只有一个数据即为结果

冒泡排序案例
    按从小到大排序，原始数组：3, 9, -1, 10, 20
    
    第一趟排序
        (1)3, 9, -1, 10, 20                 比较第一个数和第二个数的大小，3比9小，不需要交换
        (2)3, -1, 9, 10, 20                 比较第二个数和第三个数的大小，9比-1大，需要交换
        (3)3, -1, 9, 10, 20                 比较第三个数和第四个数的大小，9比10小，不需要交换
        (4)3, -1, 9, 10, 20                 比较第四个数和第五个数的大小，10比20小，不需要交换，经过四次比较后得到最大值20
    第二趟排序
        (1)-1, 3, 9, 10, 20                 比较第一个数和第二个数的大小，-1比3小，不需要交换
        (2)-1, 3, 9, 10, 20                 比较第二个数和第三个数的大小，3比9小，不需要交换
        (3)-1, 3, 9, 10, 20                 比较第三个数和第四个数的大小，9比10小，不需要交换，经过三次比较后得到最大值10
    第三趟排序
        (1)-1, 3, 9, 10, 20                 比较第一个数和第二个数的大小，-1比3小，不需要交换
        (2)-1, 3, 9, 10, 20                 比较第二个数和第三个数的大小，3比9小，不需要交换，经过两次比较后得到最大值9
    第四趟排序
        (1)-1, 3, 9, 10, 20                 比较第一个数和第二个数的大小，-1比3小，不需要交换，经过两次比较后得到最大值3